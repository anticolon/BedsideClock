/********************************************************************
  Bedside Clock — ESP32-C6 + Waveshare 1.47" LCD (320x172)
  ST7789 + Arduino_GFX + LVGL 8.4.0

  Features:
    - Big centered clock on left 3/4, weather on right 1/4
    - Rich Meteocons weather icons + temperature
    - NTP time with auto-timezone from coordinates
    - Open-Meteo weather API (free, no key needed)
    - Day/night icon variants
    - Web-based location setup (country -> city search)
    - Alarm with MP3 playback from SD card (MAX98357 I2S amp)
    - Captive Portal WiFi setup (OPEN AP)
    - OTA firmware update
    - BOOT hold (GPIO9) to force AP mode

  REQUIRED FILES (same folder as this .ino):
    - lv_conf.h
    - lv_font_clock_big.c  (generated by LVGL font converter)
    - weather_icons.h
    - icon_*.c files        (generated by LVGL image converter)

  REQUIRED LIBRARIES:
    - ESP8266Audio (for AudioFileSourceSD, AudioGeneratorMP3, AudioOutputI2S)
    - SD

  Pins (factory wired):
    LCD: DC=15, CS=14, SCK=7, MOSI=6, RST=21, BLK=22
    SD:  SCK=7(shared), MOSI=6(shared), MISO=5, CS=4
    I2S: BCLK=2, LRC=3, DIN=1
    Alarm off button: GPIO0 (active LOW, pullup)
********************************************************************/

#include <Arduino.h>
#include <SPI.h>
#include <WiFi.h>
#include <Preferences.h>
#include <HTTPClient.h>
#include <time.h>

#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <DNSServer.h>
#include <Update.h>

#include <Arduino_GFX_Library.h>

#define LV_CONF_INCLUDE_SIMPLE
#include <lvgl.h>

// SD card
#include <SD.h>

// Audio (ESP8266Audio library)
#include <AudioFileSourceSD.h>
#include <AudioGeneratorMP3.h>
#include <AudioOutputI2S.h>

#include "weather_icons.h"

// Custom 64px font for big clock digits
LV_FONT_DECLARE(lv_font_clock_big);

// ==========================================================================
//  DEFAULTS (used if nothing saved in Preferences)
// ==========================================================================
#define DEFAULT_LAT       55.84
#define DEFAULT_LON       13.34
#define DEFAULT_TZ_NAME   "Europe/Stockholm"
#define NTP_SERVER        "pool.ntp.org"
#define WEATHER_INTERVAL_MS  (15UL * 60 * 1000)  // 15 minutes

// ==========================================================================
//  PINS
// ==========================================================================
#define LCD_DC    15
#define LCD_CS    14
#define LCD_SCK    7
#define LCD_MOSI   6
#define LCD_RST   21
#define LCD_BL    22
#define BOOT_BTN_PIN  9

// SD card (shares SPI bus with LCD)
#define SD_MISO    5
#define SD_CS      4

// I2S audio (MAX98357)
#define I2S_BCLK   2
#define I2S_LRC    3
#define I2S_DOUT   1

// Rotary encoder (EC11) — also used as alarm dismiss (tap) and menu (hold 2s)
#define ENC_CLK    18   // A pin
#define ENC_DT     23   // B pin
#define ENC_SW      0   // Push switch (active LOW)

#define MENU_HOLD_MS  2000   // hold encoder button to enter menu

#define FORCE_PORTAL_HOLD_MS  1200

// ==========================================================================
//  DISPLAY  (landscape 320×172)
// ==========================================================================
Arduino_DataBus *bus = new Arduino_ESP32SPI(LCD_DC, LCD_CS, LCD_SCK, LCD_MOSI);
Arduino_GFX *gfx = new Arduino_ST7789(
  bus, LCD_RST,
  1,          // rotation = 1 (landscape 320×172)
  true,       // IPS = true (correct color inversion for Waveshare 1.47")
  172, 320,   // native W × H
  34, 0,      // col_offset1, row_offset1
  34, 0       // col_offset2, row_offset2
);

// ==========================================================================
//  LVGL buffers & pointers
// ==========================================================================
static lv_disp_draw_buf_t draw_buf;
static lv_color_t *disp_draw_buf = nullptr;

// Portal UI
static lv_obj_t *label_status   = NULL;
static lv_obj_t *label_ip       = NULL;
static lv_obj_t *boot_bar       = NULL;
static lv_obj_t *boot_bar_label = NULL;

// Clock UI
static lv_obj_t *label_time     = NULL;
static lv_obj_t *label_date     = NULL;
static lv_obj_t *label_temp     = NULL;
static lv_obj_t *label_hilo        = NULL;   // daily high/low
static lv_obj_t *label_alarm    = NULL;   // alarm indicator
static lv_obj_t *weather_icon_img = NULL;

// ==========================================================================
//  WiFi / Web / DNS
// ==========================================================================
Preferences prefs;
AsyncWebServer server(80);
bool webEnabled = true;  // web config interface on/off
DNSServer dnsServer;

bool captivePortalRunning = false;
bool clockMode = false;
String savedSSID, savedPASS, scannedOptionsHTML;

// ==========================================================================
//  SD Card
// ==========================================================================
bool sdCardOk = false;
String mp3Files[32];       // up to 32 MP3 files
int mp3FileCount = 0;

// ==========================================================================
//  Audio
// ==========================================================================
AudioGeneratorMP3 *mp3Player = nullptr;
AudioFileSourceSD *mp3Source = nullptr;
AudioOutputI2S    *audioOut  = nullptr;
bool audioPlaying = false;
bool testPlaying = false;     // test playback (non-alarm)

// ==========================================================================
//  Alarm settings (saved in Preferences)
// ==========================================================================
int    alarmHour   = 7;
int    alarmMinute = 0;
bool   alarmEnabled = false;   // armed for next trigger
String alarmSound  = "";       // MP3 filename on SD
int    alarmVolume = 50;       // 0-100 percentage
bool   alarmFiring = false;    // currently ringing
bool   alarmSnoozing = false; // snooze countdown active
unsigned long snoozeEndTime = 0;
int    snoozeDuration = 5;    // snooze minutes (saved in prefs)
bool   alarmTriggeredToday = false;  // prevent re-trigger same minute

// Alarm wake-up messages (random pick on fire)
const char* alarmMessages[] = {
  "Have a wonderful day!",
  "This day is full of potential!",
  "Dad loves you!",
  "Mom loves you!",
  "You are beautiful!",
  "You make the world brighter!",
  "Today is going to be amazing!",
  "You are so loved!",
  "The world needs your smile!",
  "You are stronger than you know!",
  "Great things await you today!",
  "You are enough, always!",
  "Today is yours to shine!",
  "Be proud of who you are!",
  "Your family believes in you!"
};
#define NUM_ALARM_MESSAGES 15
const char* currentAlarmMsg = alarmMessages[0];
int    alarmLastTrigDay = -1;  // day of month last triggered

// ==========================================================================
//  Rotary Encoder state
// ==========================================================================
volatile int encDelta = 0;          // accumulated rotation (+/- ticks)
static int encLastCLK = HIGH;
static bool encSwPressed = false;
static bool encSwHandled = false;   // prevent repeat actions
static uint32_t encSwDownTime = 0;
static bool encLongHandled = false; // long-press already acted on

// ==========================================================================
//  On-screen Menu state
// ==========================================================================
bool menuActive = false;
int  menuCursor = 0;          // 0=Back, 1=Brightness, 2=AlarmTime, 3=AlarmSound, 4=AlarmArm
bool menuEditing = false;     // currently editing a value
int  menuEditSub = 0;         // sub-field: 0=hour, 1=minute for alarm time

#define MENU_ITEMS 8
const char* menuLabels[] = { "Brightness", "Wake up", "Alarm", "Snooze", "Tune", "Volume", "Test", "Webpage" };

// Menu LVGL objects
static lv_obj_t *menuContainer = NULL;
static lv_obj_t *menuItemLabels[MENU_ITEMS] = {};
static lv_obj_t *menuValueLabels[MENU_ITEMS] = {};

// ==========================================================================
//  Location settings (saved in Preferences)
// ==========================================================================
float  cfgLat = DEFAULT_LAT;
float  cfgLon = DEFAULT_LON;
String cfgTzName = DEFAULT_TZ_NAME;
String cfgCity = "Eslöv";
String cfgCountry = "Sweden";
int    cfgUtcOffset = 3600;    // seconds, fetched from Open-Meteo
int    cfgBrightness = 255;   // 0-255 backlight PWM

// ==========================================================================
//  Weather data
// ==========================================================================
int   weatherCode    = -1;
float weatherTemp    = 0.0;
float weatherTempMin = 0.0;
float weatherTempMax = 0.0;
bool  weatherIsDay   = true;
bool  weatherValid   = false;
unsigned long lastWeatherFetch = 0;

// ==========================================================================
//  WMO Weather Code descriptions
// ==========================================================================
const char* wmoDescription(int code) {
  switch (code) {
    case 0:  return "Clear";
    case 1:  return "Mostly Clear";
    case 2:  return "Partly Cloudy";
    case 3:  return "Overcast";
    case 45: case 48: return "Foggy";
    case 51: case 53: case 55: return "Drizzle";
    case 56: case 57: return "Freezing Drizzle";
    case 61: return "Light Rain";
    case 63: return "Rain";
    case 65: return "Heavy Rain";
    case 66: case 67: return "Freezing Rain";
    case 71: return "Light Snow";
    case 73: return "Snow";
    case 75: return "Heavy Snow";
    case 77: return "Snow Grains";
    case 80: case 81: case 82: return "Showers";
    case 85: case 86: return "Snow Showers";
    case 95: return "Thunderstorm";
    case 96: case 99: return "Thunderstorm+Hail";
    default: return "Unknown";
  }
}

// ==========================================================================
//  Preferences load/save
// ==========================================================================
void loadSavedWiFi() {
  prefs.begin("wifi", true);
  savedSSID = prefs.getString("ssid", "");
  savedPASS = prefs.getString("pass", "");
  prefs.end();
}
void clearWiFiCredentials() {
  prefs.begin("wifi", false);
  prefs.remove("ssid"); prefs.remove("pass");
  prefs.end();
}
void loadLocationSettings() {
  prefs.begin("loc", true);
  cfgLat     = prefs.getFloat("lat", DEFAULT_LAT);
  cfgLon     = prefs.getFloat("lon", DEFAULT_LON);
  cfgTzName  = prefs.getString("tz", DEFAULT_TZ_NAME);
  cfgCity    = prefs.getString("city", "Eslöv");
  cfgCountry = prefs.getString("country", "Sweden");
  cfgUtcOffset = prefs.getInt("utcoff", 3600);
  cfgBrightness = prefs.getInt("bright", 255);
  webEnabled = prefs.getBool("webOn", true);
  prefs.end();
}
void saveLocationSettings() {
  prefs.begin("loc", false);
  prefs.putFloat("lat", cfgLat);
  prefs.putFloat("lon", cfgLon);
  prefs.putString("tz", cfgTzName);
  prefs.putString("city", cfgCity);
  prefs.putString("country", cfgCountry);
  prefs.putInt("utcoff", cfgUtcOffset);
  prefs.putInt("bright", cfgBrightness);
  prefs.putBool("webOn", webEnabled);
  prefs.end();
}

// ==========================================================================
//  Apply timezone from stored settings
// ==========================================================================
void applyTimezone() {
  // Use POSIX TZ string: we set a simple UTC offset.
  // For full DST support we'd need the POSIX TZ rule, but using
  // Open-Meteo's utc_offset_seconds handles DST at fetch time.
  // We re-sync NTP periodically so the offset stays current.
  configTime(cfgUtcOffset, 0, NTP_SERVER);
  Serial.printf("Timezone applied: UTC%+d (%s)\n", cfgUtcOffset/3600, cfgTzName.c_str());
}

void applyBrightness() {
  analogWrite(LCD_BL, cfgBrightness);
  Serial.printf("Brightness: %d/255\n", cfgBrightness);
}

// ==========================================================================
//  Alarm preferences
// ==========================================================================
void loadAlarmSettings() {
  prefs.begin("alarm", true);
  alarmHour    = prefs.getInt("hour", 7);
  alarmMinute  = prefs.getInt("min", 0);
  alarmEnabled = prefs.getBool("enabled", false);
  alarmSound   = prefs.getString("sound", "");
  alarmVolume  = prefs.getInt("vol", 50);
  snoozeDuration = prefs.getInt("snooze", 5);
  prefs.end();
}
void saveAlarmSettings() {
  prefs.begin("alarm", false);
  prefs.putInt("hour", alarmHour);
  prefs.putInt("min", alarmMinute);
  prefs.putBool("enabled", alarmEnabled);
  prefs.putString("sound", alarmSound);
  prefs.putInt("vol", alarmVolume);
  prefs.putInt("snooze", snoozeDuration);
  prefs.end();
}

// ==========================================================================
//  SD Card init & MP3 file scanner
// ==========================================================================
void rescanMP3Files() {
  mp3FileCount = 0;
  if (!sdCardOk) return;
  File root = SD.open("/");
  if (root) {
    File f = root.openNextFile();
    while (f && mp3FileCount < 32) {
      String name = String(f.name());
      if (!f.isDirectory() && (name.endsWith(".mp3") || name.endsWith(".MP3"))) {
        if (!name.startsWith("/")) name = "/" + name;
        mp3Files[mp3FileCount++] = name;
      }
      f = root.openNextFile();
    }
    root.close();
  }
  Serial.printf("Rescan: found %d MP3 files\n", mp3FileCount);
}

void initSDCard() {
  SPI.begin(LCD_SCK, SD_MISO, LCD_MOSI, SD_CS);
  if (SD.begin(SD_CS)) {
    sdCardOk = true;
    Serial.println("SD card mounted");
    rescanMP3Files();
  } else {
    sdCardOk = false;
    Serial.println("SD card mount failed");
  }
}

// ==========================================================================
//  Audio playback
// ==========================================================================
void applyVolume() {
  if (audioOut) audioOut->SetGain((float)alarmVolume / 100.0f);
}

void initAudio() {
  audioOut = new AudioOutputI2S();
  audioOut->SetPinout(I2S_BCLK, I2S_LRC, I2S_DOUT);
  applyVolume();
}

void startAlarmSound() {
  if (!sdCardOk || alarmSound.length() == 0) return;
  stopAlarmSound();
  applyVolume();
  mp3Source = new AudioFileSourceSD(alarmSound.c_str());
  mp3Player = new AudioGeneratorMP3();
  if (mp3Player->begin(mp3Source, audioOut)) {
    audioPlaying = true;
    Serial.printf("Alarm playing: %s\n", alarmSound.c_str());
  } else {
    Serial.println("Failed to start MP3");
    delete mp3Player; mp3Player = nullptr;
    delete mp3Source; mp3Source = nullptr;
  }
}

void stopAlarmSound() {
  if (mp3Player) {
    if (mp3Player->isRunning()) mp3Player->stop();
    delete mp3Player; mp3Player = nullptr;
  }
  if (mp3Source) {
    delete mp3Source; mp3Source = nullptr;
  }
  audioPlaying = false;
  testPlaying = false;
}

void startTestSound() {
  if (!sdCardOk || alarmSound.length() == 0) return;
  stopAlarmSound();
  applyVolume();
  mp3Source = new AudioFileSourceSD(alarmSound.c_str());
  mp3Player = new AudioGeneratorMP3();
  if (mp3Player->begin(mp3Source, audioOut)) {
    audioPlaying = true;
    testPlaying = true;
    Serial.printf("Test playing: %s at %d%%\n", alarmSound.c_str(), alarmVolume);
  } else {
    Serial.println("Failed to start test MP3");
    delete mp3Player; mp3Player = nullptr;
    delete mp3Source; mp3Source = nullptr;
  }
}

void stopTestSound() {
  stopAlarmSound();
}

void loopAudio() {
  if (mp3Player && mp3Player->isRunning()) {
    if (!mp3Player->loop()) {
      // MP3 ended — clean up
      mp3Player->stop();
      delete mp3Player; mp3Player = nullptr;
      delete mp3Source; mp3Source = nullptr;
      if (alarmFiring) {
        // Restart loop for alarm
        delay(50);  // brief pause before restarting
        mp3Source = new AudioFileSourceSD(alarmSound.c_str());
        mp3Player = new AudioGeneratorMP3();
        if (mp3Player->begin(mp3Source, audioOut)) {
          Serial.println("Alarm MP3 looping...");
        } else {
          Serial.println("Failed to restart alarm MP3");
          delete mp3Player; mp3Player = nullptr;
          delete mp3Source; mp3Source = nullptr;
          audioPlaying = false;
        }
      } else {
        // Test or other — just stop
        audioPlaying = false;
        testPlaying = false;
      }
    }
  }
}

// ==========================================================================
//  Alarm check (called every loop iteration in clock mode)
// ==========================================================================
void checkAlarm() {
  if (!alarmEnabled || alarmFiring) return;

  struct tm ti;
  if (!getLocalTime(&ti, 50)) return;

  // Reset trigger flag on new day
  if (ti.tm_mday != alarmLastTrigDay) {
    alarmTriggeredToday = false;
  }

  if (!alarmTriggeredToday && ti.tm_hour == alarmHour && ti.tm_min == alarmMinute) {
    alarmFiring = true;
    alarmTriggeredToday = true;
    alarmLastTrigDay = ti.tm_mday;
    alarmEnabled = false;  // one-shot: disable after firing
    currentAlarmMsg = alarmMessages[random(NUM_ALARM_MESSAGES)];
    saveAlarmSettings();
    startAlarmSound();
    updateAlarmLabel();
    Serial.println("ALARM TRIGGERED!");
  }
}

void dismissAlarm() {
  if (!alarmFiring && !alarmSnoozing) return;
  alarmFiring = false;
  alarmSnoozing = false;
  snoozeEndTime = 0;
  stopAlarmSound();
  updateAlarmLabel();
  Serial.println("Alarm dismissed");
}

void snoozeAlarm() {
  if (!alarmFiring) return;
  stopAlarmSound();
  alarmFiring = false;
  alarmSnoozing = true;
  snoozeEndTime = millis() + (unsigned long)snoozeDuration * 60UL * 1000UL;
  updateAlarmLabel();
  Serial.printf("Snoozing for %d minutes\n", snoozeDuration);
}

void checkSnooze() {
  if (!alarmSnoozing) return;
  if (millis() >= snoozeEndTime) {
    // Snooze expired — alarm fires again
    alarmSnoozing = false;
    alarmFiring = true;
    startAlarmSound();
    updateAlarmLabel();
    Serial.println("Snooze ended — alarm firing again!");
  }
}

void updateAlarmLabel() {
  if (!label_alarm) return;
  if (alarmFiring) {
    lv_label_set_text(label_alarm, currentAlarmMsg);
    lv_obj_set_style_text_color(label_alarm, lv_color_hex(0xFFCC44), 0);
    lv_obj_set_pos(label_alarm, 0, (gfx->height() / 2) + 34);  // quotes shifted up
    lv_obj_clear_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);
  } else if (alarmSnoozing) {
    // Show countdown
    unsigned long remaining = 0;
    if (millis() < snoozeEndTime) remaining = snoozeEndTime - millis();
    int secLeft = remaining / 1000;
    int m = secLeft / 60;
    int s = secLeft % 60;
    char buf[24];
    snprintf(buf, sizeof(buf), "Snooze: %d:%02d", m, s);
    lv_label_set_text(label_alarm, buf);
    lv_obj_set_style_text_color(label_alarm, lv_color_hex(0x7CCFFF), 0);
    lv_obj_set_pos(label_alarm, 0, (gfx->height() / 2) + 44);  // original position
    lv_obj_clear_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);
  } else if (alarmEnabled) {
    char buf[20];
    snprintf(buf, sizeof(buf), "Alarm: %02d:%02d", alarmHour, alarmMinute);
    lv_label_set_text(label_alarm, buf);
    lv_obj_set_style_text_color(label_alarm, lv_color_hex(0xFF3333), 0);
    lv_obj_set_pos(label_alarm, 0, (gfx->height() / 2) + 44);  // original position
    lv_obj_clear_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);
  } else {
    lv_obj_add_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);
  }
}

// ==========================================================================
//  Rotary Encoder reading (polled, not ISR — simpler on ESP32-C6)
// ==========================================================================
void readEncoder() {
  int clk = digitalRead(ENC_CLK);
  if (clk != encLastCLK && clk == LOW) {
    if (digitalRead(ENC_DT) != clk) {
      encDelta++;   // clockwise
    } else {
      encDelta--;   // counter-clockwise
    }
  }
  encLastCLK = clk;

  // Button state
  bool pressed = (digitalRead(ENC_SW) == LOW);
  if (pressed && !encSwPressed) {
    encSwDownTime = millis();
    encSwHandled = false;
    encLongHandled = false;
  }
  encSwPressed = pressed;
}

// Consume rotation delta (returns + or - ticks, resets to 0)
int consumeEncoderDelta() {
  int d = encDelta;
  encDelta = 0;
  return d;
}

// Check for short press (returns true once on release after <2s hold)
bool encoderShortPress() {
  if (!encSwPressed && !encSwHandled && encSwDownTime > 0 && !encLongHandled) {
    encSwHandled = true;
    encSwDownTime = 0;
    return true;
  }
  return false;
}

// Check for long press (returns true once after 2s hold while still pressed)
bool encoderLongPress() {
  if (encSwPressed && !encLongHandled && encSwDownTime > 0) {
    if (millis() - encSwDownTime >= MENU_HOLD_MS) {
      encLongHandled = true;
      return true;
    }
  }
  return false;
}

// ==========================================================================
//  On-screen Menu system
// ==========================================================================
void menuGetValueStr(int item, char *buf, int bufLen) {
  switch (item) {
    case 0: { // Brightness
      int pct = cfgBrightness * 100 / 255;
      snprintf(buf, bufLen, "%d%%", pct);
    } break;
    case 1: snprintf(buf, bufLen, "%02d:%02d", alarmHour, alarmMinute); break; // Wake up
    case 2: snprintf(buf, bufLen, "%s", alarmEnabled ? "On" : "Off"); break; // Alarm
    case 3: snprintf(buf, bufLen, "%d min", snoozeDuration); break; // Snooze
    case 4: { // Tune
      if (alarmSound.length() == 0) snprintf(buf, bufLen, "(none)");
      else {
        const char *s = alarmSound.c_str();
        if (s[0] == '/') s++;
        snprintf(buf, bufLen, "%s", s);
      }
    } break;
    case 5: snprintf(buf, bufLen, "%d%%", alarmVolume); break; // Volume
    case 6: snprintf(buf, bufLen, "%s", testPlaying ? "Stop" : "Play"); break; // Test
    case 7: snprintf(buf, bufLen, "%s", webEnabled ? "On" : "Off"); break; // Webpage
  }
}

void hideClockUI() {
  if (label_time) lv_obj_add_flag(label_time, LV_OBJ_FLAG_HIDDEN);
  if (label_date) lv_obj_add_flag(label_date, LV_OBJ_FLAG_HIDDEN);
  if (label_alarm) lv_obj_add_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);
  if (label_temp) lv_obj_add_flag(label_temp, LV_OBJ_FLAG_HIDDEN);
  if (label_hilo) lv_obj_add_flag(label_hilo, LV_OBJ_FLAG_HIDDEN);
  if (weather_icon_img) lv_obj_add_flag(weather_icon_img, LV_OBJ_FLAG_HIDDEN);
  if (label_status) lv_obj_add_flag(label_status, LV_OBJ_FLAG_HIDDEN);
  if (boot_bar) lv_obj_add_flag(boot_bar, LV_OBJ_FLAG_HIDDEN);
  if (boot_bar_label) lv_obj_add_flag(boot_bar_label, LV_OBJ_FLAG_HIDDEN);
}

void showClockUI() {
  if (label_time) lv_obj_clear_flag(label_time, LV_OBJ_FLAG_HIDDEN);
  if (label_date) lv_obj_clear_flag(label_date, LV_OBJ_FLAG_HIDDEN);
  if (label_temp) lv_obj_clear_flag(label_temp, LV_OBJ_FLAG_HIDDEN);
  if (label_hilo) lv_obj_clear_flag(label_hilo, LV_OBJ_FLAG_HIDDEN);
  if (weather_icon_img) lv_obj_clear_flag(weather_icon_img, LV_OBJ_FLAG_HIDDEN);
  if (label_status) lv_obj_clear_flag(label_status, LV_OBJ_FLAG_HIDDEN);
  updateAlarmLabel();  // will show/hide based on alarm state
}

void buildMenuUI() {
  lv_obj_t *scr = lv_scr_act();

  // Hide clock elements so they don't bleed through
  hideClockUI();

  // Full-screen overlay
  menuContainer = lv_obj_create(scr);
  lv_obj_remove_style_all(menuContainer);
  lv_obj_set_size(menuContainer, gfx->width(), gfx->height());
  lv_obj_set_pos(menuContainer, 0, 0);
  lv_obj_set_style_bg_color(menuContainer, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(menuContainer, LV_OPA_COVER, 0);
  lv_obj_clear_flag(menuContainer, LV_OBJ_FLAG_SCROLLABLE);

  // Layout: 6 rows × 22px = 132px, centered vertically in 172px
  int rowH = 20;
  int totalH = MENU_ITEMS * rowH;
  int yStart = (gfx->height() - totalH) / 2 - 8 + 5;
  int leftX = 12;
  int valX = 120;   // value column start (after longest label "Brightness:")
  int valW = gfx->width() - valX - 8;  // ~192px for values

  for (int i = 0; i < MENU_ITEMS; i++) {
    int y = yStart + i * rowH;

    // Label: "Name:"
    menuItemLabels[i] = lv_label_create(menuContainer);
    char lbl[32];
    snprintf(lbl, sizeof(lbl), "  %s:", menuLabels[i]);
    lv_label_set_text(menuItemLabels[i], lbl);
    lv_obj_set_style_text_font(menuItemLabels[i], &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_color(menuItemLabels[i], lv_color_hex(0x888888), 0);
    lv_obj_set_pos(menuItemLabels[i], leftX, y);

    // Value
    menuValueLabels[i] = lv_label_create(menuContainer);
    char vBuf[32]; menuGetValueStr(i, vBuf, sizeof(vBuf));
    lv_label_set_text(menuValueLabels[i], vBuf);
    lv_obj_set_style_text_font(menuValueLabels[i], &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_color(menuValueLabels[i], lv_color_white(), 0);
    lv_obj_set_style_text_align(menuValueLabels[i], LV_TEXT_ALIGN_RIGHT, 0);
    lv_obj_set_width(menuValueLabels[i], valW);
    lv_label_set_long_mode(menuValueLabels[i], LV_LABEL_LONG_DOT);
    lv_obj_set_pos(menuValueLabels[i], valX, y);
  }

  // Hint at bottom
  lv_obj_t *hint = lv_label_create(menuContainer);
  lv_label_set_text(hint, "Hold to exit");
  lv_obj_set_style_text_font(hint, &lv_font_montserrat_10, 0);
  lv_obj_set_style_text_color(hint, lv_color_hex(0x333333), 0);
  lv_obj_align(hint, LV_ALIGN_BOTTOM_MID, 0, -2);

  menuCursor = 0;
  menuEditing = false;
  menuEditSub = 0;
  updateMenuHighlight();
}

void destroyMenuUI() {
  if (menuContainer) {
    lv_obj_del(menuContainer);
    menuContainer = NULL;
  }
  for (int i = 0; i < MENU_ITEMS; i++) {
    menuItemLabels[i] = NULL;
    menuValueLabels[i] = NULL;
  }
}

void updateMenuHighlight() {
  for (int i = 0; i < MENU_ITEMS; i++) {
    if (!menuItemLabels[i]) continue;
    bool selected = (i == menuCursor);
    bool editing = selected && menuEditing;

    // Build label text with cursor indicator
    char lbl[32];
    snprintf(lbl, sizeof(lbl), "%s %s:", selected ? ">" : " ", menuLabels[i]);
    lv_label_set_text(menuItemLabels[i], lbl);

    // Label color: selected = cyan, normal = grey
    lv_obj_set_style_text_color(menuItemLabels[i],
      selected ? lv_color_hex(0x7CCFFF) : lv_color_hex(0x888888), 0);

    // Value color: editing = green, selected = white, normal = grey
    if (editing) {
      lv_obj_set_style_text_color(menuValueLabels[i], lv_color_hex(0x44FF44), 0);
    } else if (selected) {
      lv_obj_set_style_text_color(menuValueLabels[i], lv_color_white(), 0);
    } else {
      lv_obj_set_style_text_color(menuValueLabels[i], lv_color_hex(0x666666), 0);
    }
  }
}

void updateMenuValue(int item) {
  if (!menuValueLabels[item]) return;
  char vBuf[32]; menuGetValueStr(item, vBuf, sizeof(vBuf));
  lv_label_set_text(menuValueLabels[item], vBuf);
}

void menuOpen() {
  if (menuActive) return;
  menuActive = true;
  buildMenuUI();
  Serial.println("Menu opened");
}

void menuClose() {
  if (!menuActive) return;
  menuActive = false;
  menuEditing = false;
  if (testPlaying) stopTestSound();
  destroyMenuUI();
  showClockUI();
  Serial.println("Menu closed");
}

void menuHandleInput() {
  if (!menuActive) return;

  int delta = consumeEncoderDelta();

  if (menuEditing) {
    // Editing mode: rotate changes value, press confirms
    if (delta != 0) {
      switch (menuCursor) {
        case 0: { // Brightness
          cfgBrightness += delta * 15;
          if (cfgBrightness < 5) cfgBrightness = 5;
          if (cfgBrightness > 255) cfgBrightness = 255;
          applyBrightness();
          updateMenuValue(0);
        } break;
        case 1: { // Wake up time
          if (menuEditSub == 0) {
            alarmHour += delta;
            if (alarmHour < 0) alarmHour = 23;
            if (alarmHour > 23) alarmHour = 0;
          } else {
            alarmMinute += delta;
            if (alarmMinute < 0) alarmMinute = 59;
            if (alarmMinute > 59) alarmMinute = 0;
          }
          char tbuf[16];
          if (menuEditSub == 0)
            snprintf(tbuf, sizeof(tbuf), "[%02d]:%02d", alarmHour, alarmMinute);
          else
            snprintf(tbuf, sizeof(tbuf), "%02d:[%02d]", alarmHour, alarmMinute);
          lv_label_set_text(menuValueLabels[1], tbuf);
        } break;
        case 3: { // Snooze duration
          snoozeDuration += delta;
          if (snoozeDuration < 1) snoozeDuration = 1;
          if (snoozeDuration > 30) snoozeDuration = 30;
          updateMenuValue(3);
        } break;
        case 4: { // Tune — cycle through MP3 files
          if (mp3FileCount > 0) {
            int cur = -1;
            for (int i = 0; i < mp3FileCount; i++) {
              if (mp3Files[i] == alarmSound) { cur = i; break; }
            }
            cur += delta;
            if (cur < 0) cur = mp3FileCount - 1;
            if (cur >= mp3FileCount) cur = 0;
            alarmSound = mp3Files[cur];
            updateMenuValue(4);
          }
        } break;
        case 5: { // Volume
          alarmVolume += delta * 5;
          if (alarmVolume < 0) alarmVolume = 0;
          if (alarmVolume > 100) alarmVolume = 100;
          applyVolume();
          updateMenuValue(5);
        } break;
      }
    }

    if (encoderShortPress()) {
      if (menuCursor == 1 && menuEditSub == 0) {
        // Move to minute field
        menuEditSub = 1;
        char tbuf[16];
        snprintf(tbuf, sizeof(tbuf), "%02d:[%02d]", alarmHour, alarmMinute);
        lv_label_set_text(menuValueLabels[1], tbuf);
      } else {
        // Done editing
        menuEditing = false;
        menuEditSub = 0;
        updateMenuValue(menuCursor);
        updateMenuHighlight();
        // Save
        if (menuCursor == 0) saveLocationSettings();
        if (menuCursor >= 1 && menuCursor <= 5) saveAlarmSettings();
      }
    }
  } else {
    // Navigation mode: rotate moves cursor, press enters/acts
    if (delta != 0) {
      menuCursor += delta;
      if (menuCursor < 0) menuCursor = MENU_ITEMS - 1;
      if (menuCursor >= MENU_ITEMS) menuCursor = 0;
      updateMenuHighlight();
    }

    if (encoderShortPress()) {
      switch (menuCursor) {
        case 2: {
          // Alarm: instant toggle, no edit mode
          alarmEnabled = !alarmEnabled;
          if (alarmEnabled) alarmTriggeredToday = false;
          updateMenuValue(2);
          saveAlarmSettings();
        } break;
        case 6: {
          // Test: instant toggle test sound
          if (testPlaying) { stopTestSound(); } else { startTestSound(); }
          updateMenuValue(6);
        } break;
        case 7: {
          // Webpage: instant toggle
          webEnabled = !webEnabled;
          updateMenuValue(7);
          saveLocationSettings();
        } break;
        default: {
          // Enter edit mode for other items
          menuEditing = true;
          menuEditSub = 0;
          updateMenuHighlight();
          if (menuCursor == 1) {
            char tbuf[16];
            snprintf(tbuf, sizeof(tbuf), "[%02d]:%02d", alarmHour, alarmMinute);
            lv_label_set_text(menuValueLabels[1], tbuf);
          }
        } break;
      }
    }
  }

  // Long press always exits menu
  if (encoderLongPress()) {
    menuClose();
  }
}

// ==========================================================================
//  LVGL Flush
// ==========================================================================
static void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
{
  uint32_t w = area->x2 - area->x1 + 1;
  uint32_t h = area->y2 - area->y1 + 1;
#if LV_COLOR_16_SWAP
  gfx->draw16bitBeRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#else
  gfx->draw16bitRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#endif
  lv_disp_flush_ready(disp);
}

// ==========================================================================
//  UI helpers
// ==========================================================================
void ui_set_status(const char *txt) {
  if (label_status) lv_label_set_text(label_status, txt);
}
void ui_set_ip(const char *txt) {
  if (label_ip) lv_label_set_text(label_ip, txt);
}
void ui_show_boot_bar(bool show) {
  if (!boot_bar || !boot_bar_label) return;
  if (show) {
    lv_obj_clear_flag(boot_bar, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(boot_bar_label, LV_OBJ_FLAG_HIDDEN);
  } else {
    lv_obj_add_flag(boot_bar, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(boot_bar_label, LV_OBJ_FLAG_HIDDEN);
  }
}
void lv_update() { lv_timer_handler(); }

// ==========================================================================
//  Portal UI build
// ==========================================================================
void build_portal_ui()
{
  uint16_t scrW = gfx->width();
  lv_obj_t *scr = lv_scr_act();

  lv_obj_set_style_bg_color(scr, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(scr, LV_OPA_COVER, 0);
  lv_obj_set_style_border_width(scr, 0, 0);
  lv_obj_set_style_text_color(scr, lv_color_white(), 0);

  lv_obj_t *title = lv_label_create(scr);
  lv_label_set_text(title, "ESP32-C6 WiFi Setup");
  lv_obj_set_style_text_font(title, &lv_font_montserrat_20, 0);
  lv_obj_set_style_text_color(title, lv_color_white(), 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 8);

  label_status = lv_label_create(scr);
  lv_label_set_text(label_status, "Booting...");
  lv_obj_set_width(label_status, scrW - 20);
  lv_label_set_long_mode(label_status, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(label_status, &lv_font_montserrat_16, 0);
  lv_obj_set_style_text_align(label_status, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_style_text_color(label_status, lv_color_hex(0x7CCFFF), 0);
  lv_obj_align(label_status, LV_ALIGN_TOP_MID, 0, 40);

  label_ip = lv_label_create(scr);
  lv_label_set_text(label_ip, "");
  lv_obj_set_width(label_ip, scrW - 20);
  lv_label_set_long_mode(label_ip, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(label_ip, &lv_font_montserrat_16, 0);
  lv_obj_set_style_text_align(label_ip, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_style_text_color(label_ip, lv_color_hex(0xCCCCCC), 0);
  lv_obj_align(label_ip, LV_ALIGN_TOP_MID, 0, 72);

  boot_bar_label = lv_label_create(scr);
  lv_label_set_text(boot_bar_label, "Hold BOOT for Setup Mode");
  lv_obj_set_style_text_font(boot_bar_label, &lv_font_montserrat_14, 0);
  lv_obj_set_style_text_color(boot_bar_label, lv_color_hex(0x888888), 0);
  lv_obj_align(boot_bar_label, LV_ALIGN_BOTTOM_MID, 0, -30);

  boot_bar = lv_bar_create(scr);
  lv_obj_set_size(boot_bar, 160, 16);
  lv_obj_align(boot_bar, LV_ALIGN_BOTTOM_MID, 0, -10);
  lv_bar_set_range(boot_bar, 0, 100);
  lv_bar_set_value(boot_bar, 0, LV_ANIM_OFF);

  ui_show_boot_bar(false);
}

// ==========================================================================
//  Clock UI build  (landscape 320×172)
//  Left 3/4 (~240px): Time + Date CENTERED
//  Right 1/4 (~80px): Weather icon + temp
// ==========================================================================
void build_clock_ui()
{
  lv_obj_t *scr = lv_scr_act();
  lv_obj_clean(scr);

  lv_obj_set_style_bg_color(scr, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(scr, LV_OPA_COVER, 0);
  lv_obj_set_style_border_width(scr, 0, 0);

  uint16_t scrW = gfx->width();   // 320
  uint16_t scrH = gfx->height();  // 172
  int divX = (scrW * 3) / 4;      // ~240
  int rightW = scrW - divX;        // ~80
  int weatherShift = -12;          // shift weather left for balance

  // ---- LEFT 3/4: Time + Date, centered ----
  label_time = lv_label_create(scr);
  lv_label_set_text(label_time, "00:00");
  lv_obj_set_style_text_font(label_time, &lv_font_clock_big, 0);
  lv_obj_set_style_text_color(label_time, lv_color_white(), 0);
  lv_obj_set_style_text_letter_space(label_time, 2, 0);
  lv_obj_set_style_text_align(label_time, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_width(label_time, divX);
  lv_obj_set_pos(label_time, 0, (scrH / 2) - 44);

  label_date = lv_label_create(scr);
  lv_label_set_text(label_date, "");
  lv_obj_set_style_text_font(label_date, &lv_font_montserrat_20, 0);
  lv_obj_set_style_text_color(label_date, lv_color_hex(0xBBBBBB), 0);
  lv_obj_set_style_text_align(label_date, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_width(label_date, divX);
  lv_obj_set_pos(label_date, 0, (scrH / 2) + 15);

  // Alarm indicator (red, below date)
  label_alarm = lv_label_create(scr);
  lv_label_set_text(label_alarm, "");
  lv_obj_set_style_text_font(label_alarm, &lv_font_montserrat_20, 0);
  lv_obj_set_style_text_color(label_alarm, lv_color_hex(0xFF3333), 0);
  lv_obj_set_style_text_align(label_alarm, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_width(label_alarm, divX);
  lv_obj_set_pos(label_alarm, 0, (scrH / 2) + 44);
  lv_obj_add_flag(label_alarm, LV_OBJ_FLAG_HIDDEN);

  // ---- RIGHT 1/4: Weather (no divider) ----
  int weatherCenterX = divX + rightW / 2 + weatherShift;

  weather_icon_img = lv_img_create(scr);
  lv_img_set_src(weather_icon_img, &icon_unknown);
  lv_obj_set_pos(weather_icon_img, weatherCenterX - WEATHER_ICON_W/2, 12);

  label_temp = lv_label_create(scr);
  lv_label_set_text(label_temp, "--\xC2\xB0""C");
  lv_obj_set_style_text_font(label_temp, &lv_font_montserrat_24, 0);
  lv_obj_set_style_text_color(label_temp, lv_color_white(), 0);
  lv_obj_set_style_text_align(label_temp, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_width(label_temp, rightW);
  lv_obj_set_pos(label_temp, divX + weatherShift, 12 + WEATHER_ICON_H + 4);

  // Daily high/low
  label_hilo = lv_label_create(scr);
  lv_label_set_text(label_hilo, "");
  lv_obj_set_style_text_font(label_hilo, &lv_font_montserrat_14, 0);
  lv_obj_set_style_text_color(label_hilo, lv_color_hex(0xCCCCCC), 0);
  lv_obj_set_style_text_align(label_hilo, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_set_width(label_hilo, rightW - 2);
  lv_obj_set_pos(label_hilo, divX + weatherShift + 1, 12 + WEATHER_ICON_H + 33);

  // ---- Tiny status at bottom-right ----
  label_status = lv_label_create(scr);
  lv_label_set_text(label_status, "");
  lv_obj_set_style_text_font(label_status, &lv_font_montserrat_12, 0);
  lv_obj_set_style_text_color(label_status, lv_color_hex(0x333333), 0);
  lv_obj_align(label_status, LV_ALIGN_BOTTOM_RIGHT, -14, -2);

  // Boot bar (hidden)
  boot_bar_label = lv_label_create(scr);
  lv_label_set_text(boot_bar_label, "Hold BOOT for Setup");
  lv_obj_set_style_text_color(boot_bar_label, lv_color_hex(0x444444), 0);
  lv_obj_align(boot_bar_label, LV_ALIGN_BOTTOM_LEFT, 4, -20);
  lv_obj_add_flag(boot_bar_label, LV_OBJ_FLAG_HIDDEN);

  boot_bar = lv_bar_create(scr);
  lv_obj_set_size(boot_bar, 120, 10);
  lv_obj_align(boot_bar, LV_ALIGN_BOTTOM_LEFT, 4, -4);
  lv_bar_set_range(boot_bar, 0, 100);
  lv_bar_set_value(boot_bar, 0, LV_ANIM_OFF);
  lv_obj_add_flag(boot_bar, LV_OBJ_FLAG_HIDDEN);
}

// ==========================================================================
//  Update clock display
// ==========================================================================
static char prevTimeStr[6] = "";

void update_clock_display()
{
  struct tm ti;
  if (!getLocalTime(&ti, 100)) return;

  char timeBuf[6];
  snprintf(timeBuf, sizeof(timeBuf), "%02d:%02d", ti.tm_hour, ti.tm_min);

  if (strcmp(timeBuf, prevTimeStr) != 0) {
    lv_label_set_text(label_time, timeBuf);
    strcpy(prevTimeStr, timeBuf);
  }

  static int prevDay = -1;
  if (ti.tm_mday != prevDay) {
    prevDay = ti.tm_mday;
    const char *days[] = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
    const char *mons[] = {"Jan","Feb","Mar","Apr","May","Jun",
                          "Jul","Aug","Sep","Oct","Nov","Dec"};
    char dateBuf[32];
    snprintf(dateBuf, sizeof(dateBuf), "%s, %d %s %d",
             days[ti.tm_wday], ti.tm_mday, mons[ti.tm_mon], 1900 + ti.tm_year);
    lv_label_set_text(label_date, dateBuf);
  }
}

// ==========================================================================
//  Update weather display
// ==========================================================================
void update_weather_display()
{
  if (!weatherValid) return;

  char tempBuf[16];
  snprintf(tempBuf, sizeof(tempBuf), "%.0f\xC2\xB0""C", weatherTemp);
  lv_label_set_text(label_temp, tempBuf);

  // Daily high/low
  if (label_hilo) {
    char hiloBuf[24];
    snprintf(hiloBuf, sizeof(hiloBuf), "%.0f\xC2\xB0 / %.0f\xC2\xB0", weatherTempMin, weatherTempMax);
    lv_label_set_text(label_hilo, hiloBuf);
  }

  if (weather_icon_img) {
    const lv_img_dsc_t *icon = get_weather_icon(weatherCode, weatherIsDay);
    lv_img_set_src(weather_icon_img, icon);
  }
}

// ==========================================================================
//  Fetch weather from Open-Meteo  (also gets UTC offset for timezone)
// ==========================================================================
void fetchWeather()
{
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  char url[350];
  snprintf(url, sizeof(url),
    "https://api.open-meteo.com/v1/forecast?"
    "latitude=%.4f&longitude=%.4f"
    "&current=temperature_2m,weather_code,is_day"
    "&daily=temperature_2m_max,temperature_2m_min"
    "&forecast_days=1"
    "&timezone=%s",
    cfgLat, cfgLon, cfgTzName.c_str());

  http.begin(url);
  http.setTimeout(8000);
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    int idx;

    // Find the "current":{...} block — skip past "current_units" which appears first
    int currentBlock = payload.indexOf("\"current\":{");
    if (currentBlock < 0) currentBlock = 0; // fallback

    idx = payload.indexOf("\"temperature_2m\":", currentBlock);
    if (idx >= 0) {
      int start = idx + 17, end = start;
      while (end < (int)payload.length() &&
             (payload[end] == '-' || payload[end] == '.' || isdigit(payload[end]))) end++;
      if (end > start) weatherTemp = payload.substring(start, end).toFloat();
    }

    idx = payload.indexOf("\"weather_code\":", currentBlock);
    if (idx >= 0) {
      int start = idx + 15, end = start;
      while (end < (int)payload.length() && isdigit(payload[end])) end++;
      if (end > start) weatherCode = payload.substring(start, end).toInt();
    }

    idx = payload.indexOf("\"is_day\":", currentBlock);
    if (idx >= 0) {
      weatherIsDay = (payload[idx + 9] == '1');
    }

    // Parse utc_offset_seconds to keep timezone in sync (handles DST)
    idx = payload.indexOf("\"utc_offset_seconds\":");
    if (idx >= 0) {
      int start = idx + 21, end = start;
      if (start < (int)payload.length() && payload[start] == '-') end++;
      while (end < (int)payload.length() && isdigit(payload[end])) end++;
      int newOffset = payload.substring(start, end).toInt();
      if (newOffset != cfgUtcOffset) {
        cfgUtcOffset = newOffset;
        saveLocationSettings();
        applyTimezone();
      }
    }

    // Parse daily min/max temperatures
    // Daily block: "daily":{"time":[...],"temperature_2m_max":[X],"temperature_2m_min":[Y]}
    int dailyBlock = payload.indexOf("\"daily\":{");
    if (dailyBlock >= 0) {
      idx = payload.indexOf("\"temperature_2m_max\":[", dailyBlock);
      if (idx >= 0) {
        int start = idx + 22, end = start;  // 22 = length of "temperature_2m_max":[
        if (start < (int)payload.length() && payload[start] == '-') end++;
        while (end < (int)payload.length() &&
               (payload[end] == '.' || isdigit(payload[end]))) end++;
        if (end > start) weatherTempMax = payload.substring(start, end).toFloat();
      }
      idx = payload.indexOf("\"temperature_2m_min\":[", dailyBlock);
      if (idx >= 0) {
        int start = idx + 22, end = start;  // 22 = length of "temperature_2m_min":[
        if (start < (int)payload.length() && payload[start] == '-') end++;
        while (end < (int)payload.length() &&
               (payload[end] == '.' || isdigit(payload[end]))) end++;
        if (end > start) weatherTempMin = payload.substring(start, end).toFloat();
      }
    }

    weatherValid = true;
    Serial.printf("Weather: code=%d, temp=%.1fC, lo=%.1f hi=%.1f, day=%d\n",
                  weatherCode, weatherTemp, weatherTempMin, weatherTempMax, weatherIsDay);
  } else {
    Serial.printf("Weather HTTP error: %d\n", httpCode);
  }

  http.end();
  lastWeatherFetch = millis();
}

// ==========================================================================
//  HTML — Shared CSS
// ==========================================================================
const char CSS[] PROGMEM =
  "body{font-family:Arial;background:#111;color:#eee;padding:20px;}"
  "h2{color:#7cf;}"
  "input,select{width:100%;padding:12px;margin:6px 0;border-radius:8px;"
  "border:1px solid #444;background:#222;color:#fff;box-sizing:border-box;}"
  "button{width:100%;padding:12px;margin-top:10px;border:none;border-radius:8px;"
  "color:#fff;font-size:16px;cursor:pointer;}"
  ".btnSave{background:#28a745;} .btnClear{background:#c0392b;} .btnBlue{background:#007bff;}"
  ".box{max-width:420px;margin:auto;background:#1b1b1b;padding:20px;border-radius:12px;}"
  "a{color:#7cf;text-decoration:none;}"
  "label{display:block;margin-top:10px;font-size:14px;color:#aaa;}"
  ".nav{text-align:center;margin:15px 0;}"
  ".nav a{margin:0 10px;font-size:15px;}"
  "#citySelect{min-height:44px;}"
  ".spin{display:none;color:#7cf;margin:8px 0;}";

// ==========================================================================
//  HTML — WiFi Config Page
// ==========================================================================
String wifiConfigPage()
{
  String html;
  html.reserve(5000);
  html += "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<title>Bedside Clock</title><style>";
  html += FPSTR(CSS);
  html += "</style></head><body><div class='box'>";
  html += "<h2>WiFi Setup</h2>";
  html += "<form method='POST' action='/save'>";
  html += "<label>Select Network</label><select name='ssid_select'>" + scannedOptionsHTML + "</select>";
  html += "<label>Or type SSID manually</label><input name='ssid_manual' placeholder='SSID (optional)'>";
  html += "<label>Password</label><input name='pass' type='password' placeholder='WiFi password'>";
  html += "<button class='btnSave' type='submit'>Save &amp; Reboot</button></form>";
  html += "<form method='POST' action='/clear'><button class='btnClear' type='submit'>Clear Saved WiFi</button></form>";
  html += "<hr style='border:0;border-top:1px solid #333;margin:20px 0;'>";
  html += "<div class='nav'><a href='/settings'>Location Settings</a> | <a href='/update'>Firmware Update</a></div>";
  html += "</div></body></html>";
  return html;
}

// ==========================================================================
//  HTML — Location Settings Page
//  Country dropdown is static. City dropdown is populated via JS fetch
//  from Open-Meteo Geocoding API on the client side.
// ==========================================================================
String settingsPage()
{
  String html;
  html.reserve(8000);
  html += "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<title>Location Settings</title><style>";
  html += FPSTR(CSS);
  html += "</style></head><body><div class='box'>";
  html += "<h2>Location Settings</h2>";
  html += "<p style='color:#aaa;font-size:13px;'>Current: <b style='color:#fff;'>";
  html += cfgCity + ", " + cfgCountry;
  html += "</b> (" + String(cfgLat, 2) + ", " + String(cfgLon, 2) + ")</p>";

  html += "<form id='locForm'>";
  html += "<label>Country</label>";
  html += "<select id='countrySelect'>";
  html += "<option value=''>-- Select Country --</option>";
  // Common countries first, then a separator, then all
  const char* top[] = {"Sweden","Norway","Denmark","Finland","Germany","United Kingdom",
                       "United States","France","Spain","Italy","Netherlands","Poland",NULL};
  for (int i = 0; top[i]; i++) {
    html += "<option value='";
    html += top[i];
    html += "'";
    if (cfgCountry == top[i]) html += " selected";
    html += ">";
    html += top[i];
    html += "</option>";
  }
  html += "<option disabled>----------</option>";
  const char* more[] = {"Afghanistan","Albania","Algeria","Argentina","Australia","Austria",
    "Bangladesh","Belgium","Brazil","Canada","Chile","China","Colombia","Croatia","Czech Republic",
    "Egypt","Estonia","Ethiopia","Greece","Hungary","Iceland","India","Indonesia","Iran","Iraq",
    "Ireland","Israel","Japan","Kenya","Latvia","Lithuania","Mexico","Morocco","New Zealand",
    "Nigeria","Pakistan","Philippines","Portugal","Romania","Russia","Saudi Arabia","Serbia",
    "Singapore","Slovakia","Slovenia","South Africa","South Korea","Switzerland","Taiwan",
    "Thailand","Turkey","Ukraine","United Arab Emirates","Vietnam",NULL};
  for (int i = 0; more[i]; i++) {
    html += "<option value='";
    html += more[i];
    html += "'>";
    html += more[i];
    html += "</option>";
  }
  html += "</select>";

  html += "<label>Search City</label>";
  html += "<div style='display:flex;gap:6px;'>";
  html += "<input id='cityInput' type='text' placeholder='Type city name...' autocomplete='off' style='flex:1;'>";
  html += "<button type='button' class='btnBlue' onclick='searchCity()' style='width:auto;padding:12px 18px;margin:6px 0;'>Search</button>";
  html += "</div>";
  html += "<p class='spin' id='spinner'>Searching...</p>";
  html += "<div id='results' style='max-height:200px;overflow-y:auto;'></div>";
  html += "<input type='hidden' id='selIdx' value=''>";

  html += "<button type='submit' class='btnSave' style='margin-top:16px;'>Save Location</button>";
  html += "</form>";

  // Hidden form for POST
  html += "<form id='saveForm' method='POST' action='/saveLocation' style='display:none;'>";
  html += "<input name='lat' id='hLat'><input name='lon' id='hLon'>";
  html += "<input name='tz' id='hTz'><input name='city' id='hCity'><input name='country' id='hCountry'>";
  html += "</form>";

  html += "<hr style='border:0;border-top:1px solid #333;margin:20px 0;'>";
  html += "<div class='nav'><a href='/'>Home</a> | <a href='/update'>Firmware Update</a></div>";
  html += "</div>";

  // JavaScript
  html += "<script>";
  html += "let cities=[];";

  // Search on Enter key
  html += "document.getElementById('cityInput').addEventListener('keydown',function(e){";
  html += "  if(e.key==='Enter'){e.preventDefault();searchCity();}";
  html += "});";

  // Pick a result
  html += "function pick(i){";
  html += "  document.getElementById('selIdx').value=i;";
  html += "  document.querySelectorAll('.cr').forEach(el=>el.style.background='#222');";
  html += "  document.getElementById('cr'+i).style.background='#335';";
  html += "}";

  // Search function
  html += "async function searchCity(){";
  html += "  const q=document.getElementById('cityInput').value.trim();";
  html += "  if(q.length<2){alert('Type at least 2 characters');return;}";
  html += "  const res=document.getElementById('results');";
  html += "  const spin=document.getElementById('spinner');";
  html += "  const country=document.getElementById('countrySelect').value;";
  html += "  spin.style.display='block';res.innerHTML='';";
  html += "  document.getElementById('selIdx').value='';";
  html += "  try{";
  html += "    const r=await fetch('https://geocoding-api.open-meteo.com/v1/search?name='+encodeURIComponent(q)+'&count=30&language=en&format=json');";
  html += "    const d=await r.json();";
  html += "    cities=[];";
  html += "    if(d.results){";
  html += "      const seen=new Set();";
  html += "      d.results.forEach(r=>{";
  html += "        if(country&&r.country!==country)return;";
  html += "        const key=r.name+'|'+(r.admin1||'');";
  html += "        if(seen.has(key))return;seen.add(key);";
  html += "        cities.push({name:r.name,lat:r.latitude,lon:r.longitude,tz:r.timezone||'',admin1:r.admin1||'',country:r.country||''});";
  html += "      });";
  html += "    }";
  html += "    if(cities.length===0){";
  html += "      res.innerHTML='<p style=\"color:#888;padding:8px;\">No results'+(country?' in '+country:'')+'</p>';";
  html += "    }else{";
  html += "      let h='';";
  html += "      cities.forEach((c,i)=>{";
  html += "        const label=c.name+(c.admin1?' ('+c.admin1+')':'')+(country?'':' - '+c.country);";
  html += "        h+='<div id=\"cr'+(i+1)+'\" class=\"cr\" onclick=\"pick('+(i+1)+')\" style=\"padding:10px 12px;border-bottom:1px solid #333;background:#222;cursor:pointer;\">'+label+'</div>';";
  html += "      });";
  html += "      res.innerHTML=h;";
  html += "    }";
  html += "  }catch(e){res.innerHTML='<p style=\"color:#c00;padding:8px;\">Error searching</p>';}";
  html += "  spin.style.display='none';";
  html += "}";

  // Submit handler
  html += "document.getElementById('locForm').addEventListener('submit',function(e){";
  html += "  e.preventDefault();";
  html += "  const idx=parseInt(document.getElementById('selIdx').value);";
  html += "  if(!idx||idx<1){alert('Please search and select a city first');return;}";
  html += "  const ci=cities[idx-1];";
  html += "  document.getElementById('hLat').value=ci.lat;";
  html += "  document.getElementById('hLon').value=ci.lon;";
  html += "  document.getElementById('hTz').value=ci.tz;";
  html += "  document.getElementById('hCity').value=ci.name;";
  html += "  const c=document.getElementById('countrySelect').value||ci.country;";
  html += "  document.getElementById('hCountry').value=c;";
  html += "  document.getElementById('saveForm').submit();";
  html += "});";
  html += "</script>";

  html += "</body></html>";
  return html;
}

// ==========================================================================
//  HTML — OTA Page
// ==========================================================================
String otaPage()
{
  String html;
  html.reserve(2000);
  html += "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<title>Firmware Update</title><style>";
  html += FPSTR(CSS);
  html += "</style></head><body><div class='box'>";
  html += "<h2>Firmware OTA Update</h2>";
  html += "<form method='POST' action='/doUpdate' enctype='multipart/form-data'>";
  html += "<input type='file' name='update' accept='.bin' required>";
  html += "<button class='btnBlue' type='submit'>Upload Firmware</button></form>";
  html += "<hr style='border:0;border-top:1px solid #333;margin:20px 0;'>";
  html += "<div class='nav'><a href='/'>Home</a> | <a href='/settings'>Location</a></div>";
  html += "</div></body></html>";
  return html;
}

// ==========================================================================
//  HTML — Clock Mode Home Page (simple dashboard + links)
// ==========================================================================
String clockHomePage()
{
  String html;
  html.reserve(5000);
  html += "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<title>Bedside Clock</title><style>";
  html += FPSTR(CSS);
  html += ".slider-row{display:flex;align-items:center;gap:12px;margin:12px 0;}";
  html += ".slider-row input[type=range]{flex:1;height:6px;-webkit-appearance:none;background:#333;border-radius:3px;outline:none;}";
  html += ".slider-row input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:22px;height:22px;border-radius:50%;background:#7cf;cursor:pointer;}";
  html += ".slider-row span{min-width:36px;text-align:right;color:#fff;font-size:14px;}";
  html += ".alarm-row{display:flex;align-items:center;gap:10px;margin:8px 0;}";
  html += ".alarm-row input[type=time]{padding:10px;border-radius:8px;border:1px solid #444;background:#222;color:#fff;font-size:18px;}";
  html += ".toggle{position:relative;display:inline-block;width:52px;height:28px;}";
  html += ".toggle input{opacity:0;width:0;height:0;}";
  html += ".toggle .slider{position:absolute;cursor:pointer;inset:0;background:#333;border-radius:28px;transition:.3s;}";
  html += ".toggle .slider:before{content:'';position:absolute;height:22px;width:22px;left:3px;bottom:3px;background:#888;border-radius:50%;transition:.3s;}";
  html += ".toggle input:checked+.slider{background:#28a745;}";
  html += ".toggle input:checked+.slider:before{transform:translateX(24px);background:#fff;}";
  html += "</style></head><body><div class='box'>";
  html += "<h2>Bedside Clock</h2>";
  html += "<p style='color:#aaa;'>Location: <b style='color:#fff;'>" + cfgCity + ", " + cfgCountry + "</b></p>";
  if (weatherValid) {
    char t[16]; snprintf(t, sizeof(t), "%.0f&deg;C", weatherTemp);
    html += "<p style='color:#aaa;'>Weather: <b style='color:#fff;'>" + String(t) + ", " + wmoDescription(weatherCode) + "</b></p>";
  }

  // Alarm section
  html += "<hr style='border:0;border-top:1px solid #333;margin:16px 0;'>";
  html += "<label>Alarm</label>";
  html += "<div class='alarm-row'>";
  // Hour select (00-23)
  html += "<select id='alarmH' style='width:70px;font-size:18px;text-align:center;'>";
  for (int h = 0; h < 24; h++) {
    char hh[4]; snprintf(hh, sizeof(hh), "%02d", h);
    html += "<option value='" + String(h) + "'";
    if (h == alarmHour) html += " selected";
    html += ">" + String(hh) + "</option>";
  }
  html += "</select>";
  html += "<span style='color:#fff;font-size:20px;'>:</span>";
  // Minute select (00-59)
  html += "<select id='alarmM' style='width:70px;font-size:18px;text-align:center;'>";
  for (int m = 0; m < 60; m++) {
    char mm[4]; snprintf(mm, sizeof(mm), "%02d", m);
    html += "<option value='" + String(m) + "'";
    if (m == alarmMinute) html += " selected";
    html += ">" + String(mm) + "</option>";
  }
  html += "</select>";
  html += "<label class='toggle'><input type='checkbox' id='alarmOn'";
  if (alarmEnabled) html += " checked";
  html += "><span class='slider'></span></label>";
  html += "<span style='color:#aaa;font-size:14px;' id='alarmStatus'>";
  html += alarmEnabled ? "Armed" : (alarmFiring ? "RINGING" : "Off");
  html += "</span>";
  html += "</div>";

  // Sound selection
  html += "<label>Alarm Sound</label>";
  html += "<select id='alarmSound' style='margin-bottom:6px;'>";
  if (!sdCardOk) {
    html += "<option>No SD card</option>";
  } else if (mp3FileCount == 0) {
    html += "<option>No MP3 files found</option>";
  } else {
    for (int i = 0; i < mp3FileCount; i++) {
      html += "<option value='" + mp3Files[i] + "'";
      if (mp3Files[i] == alarmSound) html += " selected";
      html += ">" + mp3Files[i] + "</option>";
    }
  }
  html += "</select>";

  // Volume slider
  html += "<label>Alarm Volume</label>";
  html += "<div class='slider-row'>";
  html += "<input type='range' id='volSlider' min='0' max='100' value='" + String(alarmVolume) + "' oninput='volUpdate(this.value)'>";
  html += "<span id='volVal'>" + String(alarmVolume) + "%</span>";
  html += "</div>";

  // Test play/stop button
  html += "<button class='btnBlue' id='testBtn' onclick='toggleTest()' style='margin-top:4px;margin-bottom:8px;'>";
  html += testPlaying ? "Stop Test" : "Play Test";
  html += "</button>";

  if (alarmFiring) {
    html += "<button class='btnClear' onclick=\"fetch('/alarm/dismiss').then(()=>location.reload())\">Dismiss Alarm</button>";
  } else if (alarmSnoozing) {
    html += "<button class='btnClear' onclick=\"fetch('/alarm/dismiss').then(()=>location.reload())\">Cancel Snooze</button>";
  }

  html += "<hr style='border:0;border-top:1px solid #333;margin:16px 0;'>";

  // Brightness slider
  html += "<label>Display Brightness</label>";
  html += "<div class='slider-row'>";
  html += "<input type='range' id='brSlider' min='5' max='255' value='" + String(cfgBrightness) + "' oninput='brUpdate(this.value)'>";
  html += "<span id='brVal'>" + String((int)(cfgBrightness * 100 / 255)) + "%</span>";
  html += "</div>";

  html += "<div class='nav' style='margin-top:20px;'>";
  html += "<a href='/files'>Manage Sound Files</a><br><br>";
  html += "<a href='/settings'>Location Settings</a><br><br>";
  html += "<a href='/update'>Firmware Update</a>";
  html += "</div></div>";

  html += "<script>";
  // Brightness
  html += "let brTimeout=null;";
  html += "function brUpdate(v){";
  html += "  document.getElementById('brVal').textContent=Math.round(v*100/255)+'%';";
  html += "  clearTimeout(brTimeout);";
  html += "  brTimeout=setTimeout(()=>{";
  html += "    fetch('/brightness?v='+v).then(r=>r.text()).then(t=>console.log(t));";
  html += "  },200);";
  html += "}";

  // Volume slider
  html += "let volTimeout=null;";
  html += "function volUpdate(v){";
  html += "  document.getElementById('volVal').textContent=v+'%';";
  html += "  clearTimeout(volTimeout);";
  html += "  volTimeout=setTimeout(()=>{";
  html += "    fetch('/alarm/volume?v='+v).then(r=>r.text());";
  html += "  },200);";
  html += "}";

  // Test play/stop
  html += "function toggleTest(){";
  html += "  fetch('/alarm/test').then(r=>r.text()).then(r=>{";
  html += "    document.getElementById('testBtn').textContent=r==='playing'?'Stop Test':'Play Test';";
  html += "  });";
  html += "}";

  // Alarm toggle & time change
  html += "document.getElementById('alarmOn').addEventListener('change',function(){saveAlarm();});";
  html += "document.getElementById('alarmH').addEventListener('change',function(){saveAlarm();});";
  html += "document.getElementById('alarmM').addEventListener('change',function(){saveAlarm();});";
  html += "document.getElementById('alarmSound').addEventListener('change',function(){saveAlarm();});";
  html += "function saveAlarm(){";
  html += "  const h=document.getElementById('alarmH').value;";
  html += "  const m=document.getElementById('alarmM').value;";
  html += "  const t=('0'+h).slice(-2)+':'+('0'+m).slice(-2);";
  html += "  const on=document.getElementById('alarmOn').checked?1:0;";
  html += "  const s=document.getElementById('alarmSound').value;";
  html += "  const v=document.getElementById('volSlider').value;";
  html += "  const st=document.getElementById('alarmStatus');";
  html += "  fetch('/alarm/set?time='+encodeURIComponent(t)+'&on='+on+'&sound='+encodeURIComponent(s)+'&vol='+v)";
  html += "    .then(r=>r.text()).then(r=>{st.textContent=on?'Armed':'Off';});";
  html += "}";
  html += "</script>";

  html += "</body></html>";
  return html;
}

// ==========================================================================
//  WiFi Scan
// ==========================================================================
void scanNetworks()
{
  scannedOptionsHTML = "<option value=''>-- Select WiFi --</option>";
  int n = WiFi.scanNetworks(false, true);
  if (n <= 0) {
    scannedOptionsHTML += "<option value=''>No networks found</option>";
    return;
  }
  for (int i = 0; i < n; i++) {
    String ssid = WiFi.SSID(i);
    int rssi = WiFi.RSSI(i);
    String sec = (WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? "OPEN" : "SEC";
    ssid.replace("\"", "&quot;"); ssid.replace("'", "&#39;");
    ssid.replace("<", "&lt;");    ssid.replace(">", "&gt;");
    scannedOptionsHTML += "<option value=\"" + ssid + "\">" + ssid +
      " (" + rssi + " dBm " + sec + ")</option>";
  }
  WiFi.scanDelete();
}

// ==========================================================================
//  Connect WiFi
// ==========================================================================
bool connectToWiFi(const char *ssid, const char *pass, uint32_t timeoutMs)
{
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true, true);
  delay(200);
  WiFi.begin(ssid, pass);
  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < timeoutMs) {
    lv_update(); delay(10);
  }
  return (WiFi.status() == WL_CONNECTED);
}

// ==========================================================================
//  OTA Endpoints
// ==========================================================================
void setupOTAEndpoints()
{
  server.on("/update", HTTP_GET, [](AsyncWebServerRequest *r) {
    r->send(200, "text/html", otaPage());
  });
  server.on("/doUpdate", HTTP_POST,
    [](AsyncWebServerRequest *r) {
      bool ok = !Update.hasError();
      String h = "<!DOCTYPE html><html><body style='font-family:Arial;text-align:center;padding:40px;background:#111;color:#eee;'>";
      h += ok ? "<h2 style='color:#28a745;'>Update Success</h2><p>Rebooting...</p>"
              : "<h2 style='color:#c0392b;'>Update Failed</h2>";
      h += "</body></html>";
      r->send(200, "text/html", h);
      if (ok) { delay(1500); ESP.restart(); }
    },
    [](AsyncWebServerRequest *r, String filename, size_t index, uint8_t *data, size_t len, bool final) {
      if (index == 0) {
        Serial.printf("OTA Start: %s\n", filename.c_str());
        if (!Update.begin(UPDATE_SIZE_UNKNOWN)) { Update.printError(Serial); return; }
      }
      if (len && Update.write(data, len) != len) { Update.printError(Serial); return; }
      if (final) {
        if (Update.end(true)) Serial.printf("OTA OK: %u bytes\n", index + len);
        else Update.printError(Serial);
      }
    }
  );
}

// ==========================================================================
//  Captive Portal Probes
// ==========================================================================
void setupCaptiveProbeEndpoints()
{
  const char* probes[] = {
    "/generate_204", "/gen_204", "/hotspot-detect.html",
    "/library/test/success.html", "/ncsi.txt", "/connecttest.txt", "/fwlink"
  };
  for (auto &p : probes)
    server.on(p, HTTP_GET, [](AsyncWebServerRequest *r){ r->redirect("/"); });
}

// ==========================================================================
//  File Manager Page
// ==========================================================================
String fileManagerPage() {
  String html = "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<title>Sound Files</title>";
  html += "<style>";
  html += "body{font-family:Arial,sans-serif;background:#111;color:#eee;margin:0;padding:20px;}";
  html += ".wrap{max-width:400px;margin:0 auto;}";
  html += "h2{color:#7CCFFF;margin-bottom:20px;}";
  html += ".file-row{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:#1a1a1a;border-radius:8px;margin-bottom:6px;}";
  html += ".file-name{color:#eee;font-size:14px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;margin-right:10px;}";
  html += ".file-size{color:#888;font-size:12px;margin-right:10px;white-space:nowrap;}";
  html += ".btn-del{background:#c0392b;color:#fff;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:13px;}";
  html += ".btn-del:hover{background:#e74c3c;}";
  html += ".upload-box{background:#1a1a1a;border:2px dashed #333;border-radius:10px;padding:20px;text-align:center;margin-bottom:20px;}";
  html += ".upload-box input[type=file]{margin:10px 0;}";
  html += ".btn-up{background:#27ae60;color:#fff;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;font-size:15px;width:100%;}";
  html += ".btn-up:hover{background:#2ecc71;}";
  html += ".btn-up:disabled{background:#555;cursor:not-allowed;}";
  html += ".progress{width:100%;height:8px;background:#333;border-radius:4px;margin-top:10px;display:none;}";
  html += ".progress-bar{height:100%;background:#27ae60;border-radius:4px;width:0%;transition:width 0.2s;}";
  html += ".nav{text-align:center;margin-top:20px;}";
  html += ".nav a{color:#7CCFFF;text-decoration:none;}";
  html += ".status{color:#888;font-size:13px;margin-top:8px;}";
  html += ".active{color:#FFcc44;}";
  html += "</style></head><body><div class='wrap'>";
  html += "<h2>Sound Files</h2>";

  // Upload form
  html += "<div class='upload-box'>";
  html += "<p style='color:#aaa;margin:0 0 8px;'>Upload MP3 to SD card</p>";
  html += "<input type='file' id='fileIn' accept='.mp3'>";
  html += "<div class='progress' id='prog'><div class='progress-bar' id='progBar'></div></div>";
  html += "<p class='status' id='upStatus'></p>";
  html += "<button class='btn-up' id='upBtn' onclick='doUpload()'>Upload</button>";
  html += "</div>";

  // File list
  html += "<h3 style='color:#aaa;font-size:14px;margin-bottom:10px;'>Files on SD card (" + String(mp3FileCount) + ")</h3>";

  if (!sdCardOk) {
    html += "<p style='color:#c0392b;'>SD card not available</p>";
  } else if (mp3FileCount == 0) {
    html += "<p style='color:#888;'>No MP3 files found</p>";
  } else {
    for (int i = 0; i < mp3FileCount; i++) {
      String fname = mp3Files[i];
      String display = fname;
      if (display.startsWith("/")) display = display.substring(1);

      // Get file size
      File f = SD.open(fname);
      long fsize = f ? f.size() : 0;
      if (f) f.close();
      String sizeStr;
      if (fsize > 1048576) sizeStr = String(fsize / 1048576) + " MB";
      else if (fsize > 1024) sizeStr = String(fsize / 1024) + " KB";
      else sizeStr = String(fsize) + " B";

      bool isActive = (fname == alarmSound);

      html += "<div class='file-row'>";
      html += "<span class='file-name" + String(isActive ? " active" : "") + "'>" + display + "</span>";
      html += "<span class='file-size'>" + sizeStr + "</span>";
      html += "<button class='btn-del' onclick=\"delFile('" + fname + "')\">Delete</button>";
      html += "</div>";
    }
  }

  // SD card info
  if (sdCardOk) {
    uint64_t total = SD.totalBytes();
    uint64_t used = SD.usedBytes();
    html += "<p style='color:#555;font-size:12px;margin-top:12px;'>SD: " + String((int)(used/1048576)) + " MB used / " + String((int)(total/1048576)) + " MB total</p>";
  }

  html += "<div class='nav'><a href='/'>Back to Clock</a></div>";
  html += "</div>";

  // JavaScript
  html += "<script>";
  html += "function doUpload(){";
  html += "  var f=document.getElementById('fileIn').files[0];";
  html += "  if(!f){alert('Select a file first');return;}";
  html += "  if(!f.name.toLowerCase().endsWith('.mp3')){alert('Only .mp3 files');return;}";
  html += "  var btn=document.getElementById('upBtn');";
  html += "  var prog=document.getElementById('prog');";
  html += "  var bar=document.getElementById('progBar');";
  html += "  var stat=document.getElementById('upStatus');";
  html += "  btn.disabled=true;btn.textContent='Uploading...';";
  html += "  prog.style.display='block';bar.style.width='0%';";
  html += "  stat.textContent='';";
  html += "  var xhr=new XMLHttpRequest();";
  html += "  xhr.open('POST','/files/upload',true);";
  html += "  xhr.upload.onprogress=function(e){";
  html += "    if(e.lengthComputable){var p=Math.round(e.loaded*100/e.total);bar.style.width=p+'%';}";
  html += "  };";
  html += "  xhr.onload=function(){";
  html += "    if(xhr.status==200){stat.textContent='Upload complete!';stat.style.color='#27ae60';";
  html += "      setTimeout(function(){location.reload();},500);";
  html += "    }else{stat.textContent='Error: '+xhr.responseText;stat.style.color='#c0392b';}";
  html += "    btn.disabled=false;btn.textContent='Upload';";
  html += "  };";
  html += "  xhr.onerror=function(){stat.textContent='Upload failed';stat.style.color='#c0392b';btn.disabled=false;btn.textContent='Upload';};";
  html += "  var fd=new FormData();fd.append('file',f);xhr.send(fd);";
  html += "}";

  html += "function delFile(name){";
  html += "  if(!confirm('Delete '+name+'?'))return;";
  html += "  fetch('/files/delete?f='+encodeURIComponent(name))";
  html += "    .then(r=>r.text()).then(r=>{location.reload();})";
  html += "    .catch(e=>{alert('Delete failed');});";
  html += "}";
  html += "</script>";

  html += "</body></html>";
  return html;
}

// ==========================================================================
//  Setup shared web endpoints (settings + OTA) — used in both modes
// ==========================================================================
void setupSettingsEndpoints()
{
  #define WEB_GUARD() if (!webEnabled) { r->send(403, "text/plain", "Web interface disabled"); return; }

  server.on("/settings", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    r->send(200, "text/html", settingsPage());
  });

  server.on("/saveLocation", HTTP_POST, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (r->hasParam("lat", true) && r->hasParam("lon", true)) {
      cfgLat     = r->getParam("lat", true)->value().toFloat();
      cfgLon     = r->getParam("lon", true)->value().toFloat();
      cfgTzName  = r->getParam("tz", true)->value();
      cfgCity    = r->getParam("city", true)->value();
      cfgCountry = r->getParam("country", true)->value();

      if (cfgTzName.length() == 0) cfgTzName = "auto";

      saveLocationSettings();

      // Apply new timezone, re-sync NTP, and fetch weather immediately
      applyTimezone();
      fetchWeather();
      update_weather_display();

      String h = "<!DOCTYPE html><html><body style='font-family:Arial;text-align:center;padding:40px;background:#111;color:#eee;'>";
      h += "<h2 style='color:#28a745;'>Location Saved!</h2>";
      h += "<p>" + cfgCity + ", " + cfgCountry + "</p>";
      h += "<p>(" + String(cfgLat, 4) + ", " + String(cfgLon, 4) + ")</p>";
      h += "<p style='margin-top:20px;'><a href='/' style='color:#7cf;'>Back</a></p>";
      h += "</body></html>";
      r->send(200, "text/html", h);
    } else {
      r->send(400, "text/plain", "Missing parameters");
    }
  });

  server.on("/brightness", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (r->hasParam("v")) {
      int v = r->getParam("v")->value().toInt();
      if (v < 1) v = 1;
      if (v > 255) v = 255;
      cfgBrightness = v;
      applyBrightness();
      saveLocationSettings();
      r->send(200, "text/plain", "OK");
    } else {
      r->send(200, "text/plain", String(cfgBrightness));
    }
  });

  // Alarm set
  server.on("/alarm/set", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (r->hasParam("time")) {
      String t = r->getParam("time")->value();
      int colon = t.indexOf(':');
      if (colon > 0) {
        alarmHour = t.substring(0, colon).toInt();
        alarmMinute = t.substring(colon + 1).toInt();
      }
    }
    if (r->hasParam("on")) {
      alarmEnabled = r->getParam("on")->value().toInt() == 1;
      if (alarmEnabled) {
        alarmTriggeredToday = false;  // re-arm
      }
    }
    if (r->hasParam("sound")) {
      alarmSound = r->getParam("sound")->value();
    }
    if (r->hasParam("vol")) {
      alarmVolume = r->getParam("vol")->value().toInt();
      if (alarmVolume < 0) alarmVolume = 0;
      if (alarmVolume > 100) alarmVolume = 100;
      applyVolume();
    }
    saveAlarmSettings();
    updateAlarmLabel();
    r->send(200, "text/plain", "OK");
  });

  // Alarm volume (live preview)
  server.on("/alarm/volume", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (r->hasParam("v")) {
      alarmVolume = r->getParam("v")->value().toInt();
      if (alarmVolume < 0) alarmVolume = 0;
      if (alarmVolume > 100) alarmVolume = 100;
      applyVolume();
      saveAlarmSettings();
    }
    r->send(200, "text/plain", String(alarmVolume));
  });

  // Alarm test play/stop toggle
  server.on("/alarm/test", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (testPlaying) {
      stopTestSound();
      r->send(200, "text/plain", "stopped");
    } else {
      startTestSound();
      r->send(200, "text/plain", "playing");
    }
  });

  // Alarm dismiss
  server.on("/alarm/dismiss", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    dismissAlarm();
    r->send(200, "text/plain", "OK");
  });

  // File manager page
  server.on("/files", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    r->send(200, "text/html", fileManagerPage());
  });

  // File upload
  static String uploadFilename;
  static File uploadFile;

  server.on("/files/upload", HTTP_POST,
    // Request complete handler
    [](AsyncWebServerRequest *r) {
      WEB_GUARD();
      rescanMP3Files();
      r->send(200, "text/plain", "OK");
    },
    // File upload handler (called per chunk)
    [](AsyncWebServerRequest *r, String filename, size_t index, uint8_t *data, size_t len, bool final) {
      if (!webEnabled || !sdCardOk) return;
      if (index == 0) {
        // First chunk — open file
        uploadFilename = "/" + filename;
        Serial.printf("Upload start: %s\n", uploadFilename.c_str());
        uploadFile = SD.open(uploadFilename, FILE_WRITE);
        if (!uploadFile) {
          Serial.println("Failed to open file for writing");
          return;
        }
      }
      if (uploadFile && len > 0) {
        uploadFile.write(data, len);
      }
      if (final) {
        if (uploadFile) {
          uploadFile.close();
          Serial.printf("Upload complete: %s (%u bytes)\n", uploadFilename.c_str(), index + len);
        }
      }
    }
  );

  // File delete
  server.on("/files/delete", HTTP_GET, [](AsyncWebServerRequest *r) {
    WEB_GUARD();
    if (!sdCardOk) { r->send(500, "text/plain", "No SD card"); return; }
    if (!r->hasParam("f")) { r->send(400, "text/plain", "Missing filename"); return; }
    String fname = r->getParam("f")->value();
    if (SD.exists(fname)) {
      // If deleting the active alarm sound, clear it
      if (fname == alarmSound) {
        alarmSound = "";
        saveAlarmSettings();
      }
      SD.remove(fname);
      rescanMP3Files();
      Serial.printf("Deleted: %s\n", fname.c_str());
      r->send(200, "text/plain", "OK");
    } else {
      r->send(404, "text/plain", "File not found");
    }
  });
}

// ==========================================================================
//  Config Portal (AP mode)
// ==========================================================================
void startConfigPortal()
{
  WiFi.mode(WIFI_AP);
  const char *apName = "BedsideClock-SETUP";
  WiFi.softAP(apName);
  delay(300);
  IPAddress ip = WiFi.softAPIP();

  ui_set_status("AP MODE: OPEN PORTAL");
  ui_set_ip((String("SSID: ") + apName + "\nIP: " + ip.toString()).c_str());
  lv_update();

  scanNetworks();

  server.on("/", HTTP_GET, [](AsyncWebServerRequest *r) {
    r->send(200, "text/html", wifiConfigPage());
  });
  server.on("/save", HTTP_POST, [](AsyncWebServerRequest *r) {
    String ss, sm, pw;
    if (r->hasParam("ssid_select", true)) ss = r->getParam("ssid_select", true)->value();
    if (r->hasParam("ssid_manual", true)) sm = r->getParam("ssid_manual", true)->value();
    if (r->hasParam("pass", true))        pw = r->getParam("pass", true)->value();
    sm.trim(); ss.trim();
    String finalSSID = sm.length() ? sm : ss;
    if (finalSSID.length() == 0) {
      r->send(400, "text/html",
        "<html><body style='font-family:Arial;text-align:center;padding:40px;background:#111;color:#eee;'>"
        "<h2>Missing SSID</h2><p><a href='/' style='color:#7cf;'>Go back</a></p></body></html>");
      return;
    }
    prefs.begin("wifi", false);
    prefs.putString("ssid", finalSSID);
    prefs.putString("pass", pw);
    prefs.end();
    r->send(200, "text/html",
      "<html><body style='font-family:Arial;text-align:center;padding:40px;background:#111;color:#eee;'>"
      "<h2 style='color:#28a745;'>Saved!</h2><p>Rebooting...</p></body></html>");
    delay(2000); ESP.restart();
  });
  server.on("/clear", HTTP_POST, [](AsyncWebServerRequest *r) {
    clearWiFiCredentials();
    r->send(200, "text/html",
      "<html><body style='font-family:Arial;text-align:center;padding:40px;background:#111;color:#eee;'>"
      "<h2>WiFi Cleared</h2><p>Rebooting...</p></body></html>");
    delay(1500); ESP.restart();
  });

  setupSettingsEndpoints();
  setupOTAEndpoints();
  setupCaptiveProbeEndpoints();
  server.onNotFound([](AsyncWebServerRequest *r) { r->redirect("/"); });
  server.begin();

  dnsServer.start(53, "*", WiFi.softAPIP());
  captivePortalRunning = true;
}

// ==========================================================================
//  BOOT Hold Check
// ==========================================================================
bool checkBootHoldWithProgress()
{
  ui_show_boot_bar(true);
  lv_bar_set_value(boot_bar, 0, LV_ANIM_OFF);
  lv_update();

  uint32_t start = millis();
  while (millis() - start < FORCE_PORTAL_HOLD_MS) {
    if (digitalRead(BOOT_BTN_PIN) == HIGH) {
      lv_bar_set_value(boot_bar, 0, LV_ANIM_OFF);
      ui_show_boot_bar(false); lv_update();
      return false;
    }
    int pct = (int)((millis() - start) * 100UL / FORCE_PORTAL_HOLD_MS);
    lv_bar_set_value(boot_bar, min(pct, 100), LV_ANIM_OFF);
    lv_update(); delay(10);
  }
  lv_bar_set_value(boot_bar, 100, LV_ANIM_OFF);
  lv_update(); delay(200);
  ui_show_boot_bar(false); lv_update();
  return true;
}

// ==========================================================================
//  SETUP
// ==========================================================================
void setup()
{
  Serial.begin(115200);
  delay(200);

  pinMode(BOOT_BTN_PIN, INPUT_PULLUP);
  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);

  // ---- Display init ----
  pinMode(LCD_BL, OUTPUT);
  analogWrite(LCD_BL, 255);  // full brightness until settings load
  gfx->begin();
  gfx->fillScreen(0x0000);

  // ---- LVGL init ----
  lv_init();

  uint32_t bufSize = (uint32_t)gfx->width() * 40;
  disp_draw_buf = (lv_color_t *)heap_caps_malloc(bufSize * sizeof(lv_color_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
  if (!disp_draw_buf)
    disp_draw_buf = (lv_color_t *)heap_caps_malloc(bufSize * sizeof(lv_color_t), MALLOC_CAP_8BIT);
  if (!disp_draw_buf) { Serial.println("LVGL buf alloc failed!"); while (1) delay(1000); }

  lv_disp_draw_buf_init(&draw_buf, disp_draw_buf, NULL, bufSize);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res  = gfx->width();
  disp_drv.ver_res  = gfx->height();
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  Serial.printf("Display: %d x %d\n", gfx->width(), gfx->height());

  // Force dark
  lv_obj_set_style_bg_color(lv_scr_act(), lv_color_black(), 0);
  lv_obj_set_style_bg_opa(lv_scr_act(), LV_OPA_COVER, 0);
  lv_obj_set_style_text_color(lv_scr_act(), lv_color_white(), 0);

  build_portal_ui();

  // Load saved location settings
  loadLocationSettings();
  applyBrightness();

  // Load alarm settings
  loadAlarmSettings();

  // Init SD card and audio
  initSDCard();
  initAudio();

  ui_set_status("Hold BOOT for Setup");
  ui_set_ip("Release to boot normal");
  lv_update();
  delay(150);

  // Check BOOT button hold
  if (digitalRead(BOOT_BTN_PIN) == LOW) {
    if (checkBootHoldWithProgress()) {
      ui_set_status("FORCED SETUP MODE");
      ui_set_ip("Starting portal...");
      lv_update(); delay(400);
      startConfigPortal();
      return;
    }
  }

  // Normal boot — try WiFi
  ui_set_status("Loading WiFi...");
  ui_set_ip(""); lv_update();

  loadSavedWiFi();

  if (savedSSID.length() > 0) {
    ui_set_status("Connecting WiFi...");
    ui_set_ip(savedSSID.c_str()); lv_update();

    if (connectToWiFi(savedSSID.c_str(), savedPASS.c_str(), 8000)) {
      Serial.println("WiFi connected, starting clock mode");

      // Apply timezone and sync NTP
      applyTimezone();

      ui_set_status("Syncing time...");
      lv_update();
      delay(1500);

      // Build clock UI
      build_clock_ui();
      clockMode = true;

      // Initial weather fetch
      fetchWeather();
      update_weather_display();
      updateAlarmLabel();

      if (label_status) {
        lv_label_set_text(label_status, WiFi.localIP().toString().c_str());
      }

      // Start web server (clock mode — settings + OTA)
      server.on("/", HTTP_GET, [](AsyncWebServerRequest *r) {
        if (!webEnabled) { r->send(403, "text/plain", "Web interface disabled"); return; }
        r->send(200, "text/html", clockHomePage());
      });
      setupSettingsEndpoints();
      setupOTAEndpoints();
      server.onNotFound([](AsyncWebServerRequest *r) { r->redirect("/"); });
      server.begin();

      return;
    } else {
      ui_set_status("WiFi Failed!");
      ui_set_ip("Falling back to AP...");
      lv_update(); delay(1000);
    }
  }

  startConfigPortal();
}

// ==========================================================================
//  LOOP
// ==========================================================================
void loop()
{
  lv_timer_handler();

  if (captivePortalRunning) {
    dnsServer.processNextRequest();
  }

  if (clockMode) {
    // Read encoder every loop (must be fast for reliable reading)
    readEncoder();

    // Menu handling
    if (menuActive) {
      menuHandleInput();
      // Don't update clock display while menu is open
    } else {
      update_clock_display();

      // Update snooze countdown display every loop
      if (alarmSnoozing) {
        updateAlarmLabel();
      }

      // Encoder short-press: snooze if ringing, ignore during snooze
      if (alarmFiring && encoderShortPress()) {
        snoozeAlarm();
      }

      // Encoder long-press: dismiss alarm/snooze if active, open menu if not
      if (encoderLongPress()) {
        if (alarmFiring || alarmSnoozing) {
          dismissAlarm();
        } else {
          menuOpen();
        }
      }

      // Consume unused presses when not in alarm state
      if (!alarmFiring && !alarmSnoozing) encoderShortPress();
    }

    // Audio processing (always runs)
    loopAudio();

    // Check alarm trigger
    checkAlarm();

    // Check snooze expiry
    checkSnooze();

    // Periodic weather refresh
    if (millis() - lastWeatherFetch > WEATHER_INTERVAL_MS) {
      fetchWeather();
      update_weather_display();
    }

    // Check BOOT button for re-entering setup
    static bool bootHeld = false;
    static uint32_t bootStart = 0;
    if (digitalRead(BOOT_BTN_PIN) == LOW) {
      if (!bootHeld) {
        bootHeld = true;
        bootStart = millis();
        ui_show_boot_bar(true);
      }
      uint32_t held = millis() - bootStart;
      int pct = (int)(held * 100UL / FORCE_PORTAL_HOLD_MS);
      lv_bar_set_value(boot_bar, min(pct, 100), LV_ANIM_OFF);

      if (held >= FORCE_PORTAL_HOLD_MS) {
        ESP.restart();
      }
    } else {
      if (bootHeld) {
        bootHeld = false;
        lv_bar_set_value(boot_bar, 0, LV_ANIM_OFF);
        ui_show_boot_bar(false);
      }
    }
  }

  delay(5);
}
